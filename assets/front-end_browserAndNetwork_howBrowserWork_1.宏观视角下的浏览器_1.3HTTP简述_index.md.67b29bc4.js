import{_ as a,o as e,c as s,Q as t}from"./chunks/framework.9bc09dc8.js";const o="/assets/http请求.af419c0e.webp",l="/assets/baidu.aa5cc5f9.png",p="/assets/http返回.1231ee65.webp",r="/assets/重定向.d5df9612.webp",n="/assets/资源缓存.1dba92b2.webp",m=JSON.parse('{"title":"HTTP 协议简述","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/browserAndNetwork/howBrowserWork/1.宏观视角下的浏览器/1.3HTTP简述/index.md","filePath":"front-end/browserAndNetwork/howBrowserWork/1.宏观视角下的浏览器/1.3HTTP简述/index.md","lastUpdated":1692596387000}'),c={name:"front-end/browserAndNetwork/howBrowserWork/1.宏观视角下的浏览器/1.3HTTP简述/index.md"},i=t('<h1 id="http-协议简述" tabindex="-1">HTTP 协议简述 <a class="header-anchor" href="#http-协议简述" aria-label="Permalink to &quot;HTTP 协议简述&quot;">​</a></h1><h2 id="什么是-http-协议" tabindex="-1">什么是 HTTP 协议 <a class="header-anchor" href="#什么是-http-协议" aria-label="Permalink to &quot;什么是 HTTP 协议&quot;">​</a></h2><p>HTTP 即<strong>超文本传输协议</strong>，它建立在 TCP 协议之上，是一个用于传输超媒体文档（例如 HTML）的<strong>应用层</strong>协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端—服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。HTTP 是<strong>无状态</strong>协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。</p><h2 id="浏览器发起-http-请求的流程" tabindex="-1">浏览器发起 HTTP 请求的流程 <a class="header-anchor" href="#浏览器发起-http-请求的流程" aria-label="Permalink to &quot;浏览器发起 HTTP 请求的流程&quot;">​</a></h2><p>下面是当我们访问一个网址，例如<a href="https://time.geekbang.org/" target="_blank" rel="noreferrer">百度</a>，浏览器请求过程中的一系列动作：</p><h3 id="_1-构建请求" tabindex="-1">1.构建请求 <a class="header-anchor" href="#_1-构建请求" aria-label="Permalink to &quot;1.构建请求&quot;">​</a></h3><p>浏览器构建请求行信息，构建好后发起请求：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">GET</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">/index.html</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">HTTP1.1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">GET</span><span style="color:#24292E;"> </span><span style="color:#032F62;">/index.html</span><span style="color:#24292E;"> </span><span style="color:#032F62;">HTTP1.1</span></span></code></pre></div><h3 id="_2-查找缓存" tabindex="-1">2.查找缓存 <a class="header-anchor" href="#_2-查找缓存" aria-label="Permalink to &quot;2.查找缓存&quot;">​</a></h3><p>在发起网络请求之前，浏览器会查询本地缓存中是否已有要请求资源的副本，如果有，直接拦截并结束请求。</p><h3 id="_3-查找-ip-地址和端口" tabindex="-1">3.查找 IP 地址和端口 <a class="header-anchor" href="#_3-查找-ip-地址和端口" aria-label="Permalink to &quot;3.查找 IP 地址和端口&quot;">​</a></h3><p>如果没有找到缓存，浏览器将发起网络请求。首先要获取当前请求域名的 IP 地址及端口号。</p><p>浏览器会先查询本地 DNS 缓存时候有当前请求域名的查询记录，如果没有则请求 DNS 查询域名对应的 IP 地址。</p><p>如果 url 没有指明特定的端口号，http 请求默认为 80 端口。（https 为 443）</p><h3 id="_4-等待-tcp-队列" tabindex="-1">4.等待 TCP 队列 <a class="header-anchor" href="#_4-等待-tcp-队列" aria-label="Permalink to &quot;4.等待 TCP 队列&quot;">​</a></h3><p>在获得 IP 地址和端口号之后，理论上应该建立 TCP 连接了，但是这里还有一个前置条件：</p><p>Chrome 有一个机制：同一个域名同时最多只能建立 6 个 TCP 连接，超过的连接将进入队列等待。</p><p>当请求数量小于 6 时，会进入下一步，建立 TCP 连接。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>http/1.1 一个 tcp 同时只能处理一个请求，浏览器会为每个域名维护 6 个 tcp 连接，但是每个 tcp 连接是可以复用的，也就是处理完一个请求之后，不断开这个 tcp 连接，可以用来处理下个 http 请求。</p><p>不过 http2 是可以并行请求资源的，所以如果使用 http2，浏览器只会为每个域名维护一个 tcp 连接。</p></div><h3 id="_5-建立-tcp-连接" tabindex="-1">5.建立 TCP 连接 <a class="header-anchor" href="#_5-建立-tcp-连接" aria-label="Permalink to &quot;5.建立 TCP 连接&quot;">​</a></h3><p>浏览器通过 TCP 与服务器建立连接，过程可参考<a href="./../1.2TCP协议/">上一章</a>。</p><h3 id="_6-发送-http-请求" tabindex="-1">6.发送 HTTP 请求 <a class="header-anchor" href="#_6-发送-http-请求" aria-label="Permalink to &quot;6.发送 HTTP 请求&quot;">​</a></h3><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p><p><img src="'+o+'" alt="http请求数据格式"></p><h2 id="服务端处理-http-请求过程" tabindex="-1">服务端处理 HTTP 请求过程 <a class="header-anchor" href="#服务端处理-http-请求过程" aria-label="Permalink to &quot;服务端处理 HTTP 请求过程&quot;">​</a></h2><h3 id="_1-返回请求" tabindex="-1">1.返回请求 <a class="header-anchor" href="#_1-返回请求" aria-label="Permalink to &quot;1.返回请求&quot;">​</a></h3><p>一旦服务器处理结束，便可以返回数据给浏览器了。可以通过工具软件 curl 来查看返回请求数据：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-i</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">www.baidu.com</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">curl</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-i</span><span style="color:#24292E;"> </span><span style="color:#032F62;">www.baidu.com</span></span></code></pre></div><p><img src="'+l+'" alt="curl baidu.com"></p><p>可以看到返回的结果可以分为响应行、响应头、响应体，如下图所示：</p><p><img src="'+p+'" alt="http返回体"></p><ul><li>响应行：包含协议版本和状态码</li><li>响应头：包含服务器自身的一些信息，如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</li><li>响应体：通常即为 HTML 的实际内容</li></ul><h3 id="_2-断开连接" tabindex="-1">2.断开连接 <a class="header-anchor" href="#_2-断开连接" aria-label="Permalink to &quot;2.断开连接&quot;">​</a></h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：Connection:Keep-Alive 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。</p><p><strong>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</strong></p><p>比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p><h3 id="_3-重定向" tabindex="-1">3.重定向 <a class="header-anchor" href="#_3-重定向" aria-label="Permalink to &quot;3.重定向&quot;">​</a></h3><p>当服务端返回的状态码为 301，或 302 时，即告诉浏览器需重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中。</p><p>例如输入的是 <code>geekbang.org</code>，最终打开的却是 <a href="https://www.geekbang.org" target="_blank" rel="noreferrer">https://www.geekbang.org</a> 了。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-I</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">geekbang.org</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">curl</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-I</span><span style="color:#24292E;"> </span><span style="color:#032F62;">geekbang.org</span></span></code></pre></div><p><img src="'+r+'" alt="重定向"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>301 与 302 的区别： 301：永久重定向，浏览器可缓存，不用每次都访问服务器 302：临时重定向，每次都会访问对方服务器</p></div><h2 id="浏览器缓存-提高二次加载速度" tabindex="-1">浏览器缓存：提高二次加载速度 <a class="header-anchor" href="#浏览器缓存-提高二次加载速度" aria-label="Permalink to &quot;浏览器缓存：提高二次加载速度&quot;">​</a></h2><ul><li>DNS 缓存</li><li>页面资源缓存 <img src="'+n+'" alt="资源缓存过程"></li></ul>',44),h=[i];function d(b,T,u,P,_,g){return e(),s("div",null,h)}const C=a(c,[["render",d]]);export{m as __pageData,C as default};
